# Base on https://github.com/gf3/dotfiles

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi

# Colors
# ------
Black='\e[30m'        # Black
Red='\e[31m'          # Red
Green='\e[32m'        # Green
Yellow='\e[33m'       # Yellow
Blue='\e[34m'         # Blue
Purple='\e[35m'       # Purple
Cyan='\e[36m'         # Cyan
Gray='\e[90m'         # Gray
White='\e[97m'        # White

Reset='\e[0m'         # Reset prompt styles
Bold='\e[1m'          # Bold
Underline='\e[4m'     # Underline

# Git colors
# ------
if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  c_reset="${Reset}"
  c_user="${Bold}${Yellow}"
  c_path="${Bold}${Yellow}"
  c_git_clean="${Bold}${Cyan}"
  c_git_dirty="${Bold}${Red}"
else
  c_reset=
  c_user=
  c_git_clean=
  c_git_path=
  c_git_dirty=
fi

# Function to assemble the Git parsingart of our prompt.
git_prompt ()
{
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    return 0
  fi

  git_branch=$(git branch 2>/dev/null | sed -n '/^\*/s/^\* //p')

  if git diff --quiet 2>/dev/null >&2; then
    git_color="$c_git_clean"
  else
    git_color="$c_git_dirty"
  fi

  echo "$git_color$git_branch"
}

function parse_git_dirty() {
    [[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]] && echo "*"
}

function parse_git_branch() {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
}

export PS1="${Bold}${Purple}\u${Gray} at ${Cyan}\h${Gray} in ${Yellow}\w${Gray}\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")${Purple}$(git_prompt)${Gray}\n> ${Reset}"
export PS2="${Cyan}â†’ ${Reset}"